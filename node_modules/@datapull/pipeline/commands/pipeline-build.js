exports.build = function (config) {
  // 1 - get all the pipeline steps:
  const pipelineSteps = {
    configurations: [],
    origins: [],
    transformers: [],
    destinations: [],
  }

  Object.keys(config)
    .filter(i => config[i].runner)  // all top-level objects that do not specify a "runner" are ignored
    .forEach(k => {
      const runner = config[k].runner;
      const runnerParts = runner.split(".");
      const runnerModuleName = `@datapull/${runnerParts[0]}`;
      const runnerModule = require(runnerModuleName).datapullStep;

      if (runnerModule.isConfiguration) {
        pipelineSteps.configurations.push({ k, runner: new runnerModule.constructor(config[k]) })
      }

      if (runnerModule.isTransformer) {
        pipelineSteps.transformers.push({ k, runner: new runnerModule.constructor(config[k]) })
      }

      if (runnerModule.isOrigin) {
        pipelineSteps.origins.push({ k, runner: new runnerModule.constructor(config[k]) })
      }

      if (runnerModule.isDestination) {
        pipelineSteps.destinations.push({ k, runner: new runnerModule.constructor(config[k]) })
      }
    });

  // 2 - start building pipelines (one yaml file may result in multiple pipelines)
  let pipelines = [];

  // 2.1 - configuration:
  const configProcessors = [];
  pipelineSteps.configurations.forEach(configurator => {
    if (!configurator.runner.buildPipelines) {
      console.warn(configurator.k, 'does not define `buildPipelines` method')
      return;
    }
    pipelines = configurator.runner.buildPipelines(pipelines);

    if (configurator.runner.process) {
      configProcessors.push(configurator.runner)
    }
  });
  pipelines = pipelines.map(i => { return {config: i, configProcessors}; });

  // 3 - set up origins:
  pipelineSteps.origins.forEach(origin => {
    if (!origin.runner.originDeclaration) {
      console.warn(origin.k, 'does not define `originDeclaration` method')
      return;
    }

    const newPipelines = [];

    pipelines.forEach(p => {
      const originDeclaration = origin.runner.originDeclaration;

      // if there is already an origin defined, branch out a new pipeline with this origin
      if (p.origin) {
        newPipelines.push(p);
        newPipelines.push(Object.assign({}, p, { origin: Object.assign({}, originDeclaration) }));
      } else {
        p.origin = Object.assign({}, originDeclaration);
        newPipelines.push(p);
      }
    });

    pipelines = newPipelines;
  });

  // 4 - set up transformers:
  pipelineSteps.transformers.forEach(transformer => {
    if (!transformer.runner.buildPipelines) {
      console.warn(transformer.k, 'does not define `buildPipelines` method')
      return;
    }
    pipelines = transformer.runner.buildPipelines(pipelines);
  });

  // 5 - set up destinations:
  pipelineSteps.destinations.forEach(destination => {
    if (!destination.runner.buildPipelines) {
      console.warn(destination.k, 'does not define `buildPipelines` method')
      return;
    }
    pipelines = destination.runner.buildPipelines(pipelines);
  });

  return pipelines;
};
